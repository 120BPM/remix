#!/usr/bin/env node

const program = require('commander')
const version = require('../package.json').version

program
  .command('version')
  .description('outputs version number')
  .action(() => {
    console.log(version)
    process.exit(0)
  })

program
  .command('help')
  .description('outputs usage information')
  .action(() => {
    program.help()
    process.exit(0)
  })

program
  .option('-f, --file [filename]', 'solidity filename to debug')
  .option('--tx [txHash]', 'transaction hash to debug')
  .option('--node [url]', 'node to connect to')
  .parse(process.argv)

if (!program.tx) {
  console.error('no tx specified. please specify with --tx <txHash>')
  process.exit(1)
}

if (!program.file) {
  console.error('no file specified. please specify with --file <filepath>')
  process.exit(1)
}

var CmdLine = require('../src/cmdline/index.js')

var solc = require('solc')
var fs = require('fs')

// var filename = 'test/sol/simple_storage.sol'
// var shortFilename = 'simple_storage.sol'
var filename = program.file
var shortFilename = program.file

var inputJson = {
  language: 'Solidity',
  sources: {
  },
  settings: {
    optimizer: {
      // enabled: true,
      enabled: false,
      runs: 200
    },
    outputSelection: {
      '*': {
        '': [ 'legacyAST' ],
        '*': [ 'abi', 'metadata', 'devdoc', 'userdoc', 'evm.legacyAssembly', 'evm.bytecode', 'evm.deployedBytecode', 'evm.methodIdentifiers', 'evm.gasEstimates' ]
      }
    }
  }
}

inputJson.sources[shortFilename] = {content: fs.readFileSync(filename).toString()}

console.log('compiling...')

let compilationData = JSON.parse(solc.compileStandardWrapper(JSON.stringify(inputJson)))
var compilation = {}
compilation.data = compilationData
compilation.source = { sources: inputJson.sources }

let url = (program.node || 'http://localhost:8545')

console.log('connecting to... ' + url)

var cmdLine = new CmdLine()
cmdLine.connect('http', url)
cmdLine.loadCompilationResult(compilation)
cmdLine.initDebugger()

var tx = program.tx

cmdLine.startDebug(tx, shortFilename)

cmdLine.events.on('source', () => {
  cmdLine.getSource().forEach(console.dir)
})

const repl = require('repl')

function showActions () {
  const actions = []
  actions.push('actions: ')

  if (cmdLine.canGoPrevious()) {
    actions.push('(p)revious')
  }
  if (cmdLine.canGoNext()) {
    actions.push('(n)ext')
  }

  actions.push('(vl) var local')
  actions.push('(vg) var global')
  actions.push('(vc) var contract')

  console.log('')
  console.log(actions.join(' | '))
}

function simplifyVars (data) {
  if (!data) return
  const newData = {}

  Object.keys(data).forEach((key) => {
    const field = data[key]
    newData[`${key} (${field.type})`] = field.value
  })

  for (const debugVar of Object.keys(newData)) {
    const value = newData[debugVar]
    console.log(`${debugVar}: ` + `${value}`)
  }
}

function getVarsInLine (localVars, contractVars, globalVars, line) {
  if (!line) return {}
  let foundVars = {}

  let varList = [localVars, contractVars, globalVars]
  varList.forEach((variables) => {
    Object.keys(variables).forEach((varName) => {
      if (line.indexOf(varName) >= 0) {
        const value = variables[varName]
        foundVars[varName] = value
      }
    })
  })

  return foundVars
}

async function getGlobals (txHash) {
  const globals = {}

  let tx = await cmdLine.web3.eth.getTransaction(txHash)
  let block = await cmdLine.web3.eth.getBlock(tx.blockHash)

  globals['block.blockHash'] = {type: 'bytes32', value: tx.blockHash}
  globals['block.number'] = {type: 'uint256', value: tx.blockNumber}
  globals['block.coinbase'] = {type: 'address payable', value: block.miner}
  globals['block.difficulty'] = {type: 'uint256', value: block.difficulty.toString()}
  globals['block.gaslimit'] = {type: 'uint256', value: block.gasLimit}
  globals['block.timestamp'] = {type: 'uint256', value: block.timestamp}
  globals['msg.sender'] = {type: 'address payable', value: tx.from}
  globals['msg.gas'] = {type: 'uint256', value: tx.gas}
  globals['msg.gasPrice'] = {type: 'uint256', value: tx.gasPrice.toString()}
  globals['msg.value'] = {type: 'uint256', value: tx.value.toString()}
  globals['now'] = {type: 'uint256', value: block.timestamp}

  return globals
}

repl.start({
  prompt: '> ',
  eval: async (cmd, context, filename, cb) => {
    let command = cmd.trim()
    if (command === 'next' || command === 'n') {
      cmdLine.stepOverForward(true)

      let globals = await getGlobals(cmdLine.txHash)
      let vars = cmdLine.getVars()
      let line = cmdLine.getCurrentLine()
      let foundVars = await getVarsInLine(vars.locals, vars.contract, globals, line)
      simplifyVars(foundVars)
    }
    if (command === 'previous' || command === 'p' || command === 'prev') {
      cmdLine.stepOverBack(true)

      let globals = await getGlobals(cmdLine.txHash)
      let vars = cmdLine.getVars()
      let line = cmdLine.getCurrentLine()
      let foundVars = getVarsInLine(vars.locals, vars.contract, globals, line)
      simplifyVars(foundVars)
    }
    if (command === 'step' || command === 's') {
      cmdLine.stepIntoForward(true)
    }
    if (command === 'stepback' || command === 'sb') {
      cmdLine.stepIntoBack(true)
    }
    if (command === 'exit' || command === 'quit' || command === 'q') {
      process.exit(0)
    }
    if (command === 'var local' || command === 'v l' || command === 'vl') {
      let vars = cmdLine.getVars()
      simplifyVars(vars.locals)
      // cmdLine.displayLocals()
    }
    if (command === 'var contract' || command === 'v c' || command === 'vc') {
      let vars = cmdLine.getVars()
      simplifyVars(vars.contract)
      // cmdLine.displayGlobals()
    }
    if (command === 'var global' || command === 'v g' || command === 'vg') {
      let globals = await getGlobals(cmdLine.txHash)
      simplifyVars(globals)
    }
    if (command.split(' ')[0] === 'jump') {
      let stepIndex = parseInt(command.split(' ')[1], 10)
      cmdLine.jumpTo(stepIndex)
    }
    showActions()
    cb(null, '')
  }
})

module.exports = cmdLine

